{"version":3,"sources":["Pathfinding/Algorithms/BFS.js","Pathfinding/Algorithms/DFS.js","Pathfinding/Node/Node.js","Pathfinding/Pathfinding.js","App.js","serviceWorker.js","index.js"],"names":["isValid","row","col","grid","length","isVisited","module","exports","bfs","startNode","finishNode","dx","dy","visitedNodesinOrder","queue","push","curNode","shift","type","i","newNode","previousNode","dfs","stack","temp","pop","Node","this","props","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","React","Component","Pathfinding","state","mouseIsPressed","algorithm","visualizeButton","visualizing","speed","boardClear","myRef","createRef","rows","createCell","makeFirstGrid","setState","newGrid","getNewGridWithWallToggled","visitedNodesInOrder","shortestPathNodes","shortestPath","animateVisitedPath","updateState","setTimeout","node","checkStartEnd","document","getElementById","visualizeShortestPath","clearObject","block","slice","startpoint","endpoint","e","target","value","parseInt","checkBlocks","visualizeBFS","visualizeDFS","onChange","onChangeAlgorithm","bind","onClick","visualize","clearBoard","onChangeSpeed","defaultValue","ref","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","distance","Infinity","isWall","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.60b93b6f.chunk.js","sourcesContent":["module.exports = {\r\n\r\n\r\nbfs :function (grid, startNode, finishNode){\r\n    var dx=[0,-1,0,1]\r\n    var dy =[1,0,-1,0]\r\n    var visitedNodesinOrder = []\r\n    var queue = [];\r\n    queue.push(startNode)\r\n    while (queue.length >0){\r\n       var curNode =  queue.shift()\r\n        if( curNode.type ==='end') return visitedNodesinOrder\r\n        if( grid[curNode.row][curNode.col].type ==='wall') continue\r\n        visitedNodesinOrder.push(curNode)\r\n\r\n        for (var i = 0; i< 4 ;i++){\r\n            if (isValid(curNode.row +dx[i],curNode.col+dy[i], grid)){\r\n                let newNode = grid[curNode.row +dx[i]][curNode.col+dy[i]]\r\n                newNode.previousNode = curNode\r\n                newNode.isVisited = true;\r\n                queue.push(newNode)\r\n\r\n        }\r\n\r\n\r\n\r\n}\r\n}\r\nreturn visitedNodesinOrder\r\n\r\n}\r\n\r\n}\r\nfunction isValid(row,col,grid) {\r\n    if(row < 0 || row >= grid.length|| col< 0|| col >= grid[0].length) return false\r\n    if(grid[row][col].isVisited ) return false\r\n\r\n    return true;\r\n}","module.exports = {\r\n\r\n\r\n    dfs :function (grid, startNode, finishNode){\r\n        var dy=[-1,0,1,0]\r\n        var dx =[0,1,0,-1]\r\n        var visitedNodesinOrder = []\r\n        var curNode = null\r\nvar stack = [];\r\n        stack.push(startNode)\r\n        while (stack.length >0){\r\n            var temp = stack.pop()\r\n            temp.previousNode = curNode\r\n            temp.isVisited = true;\r\n            curNode =  temp\r\n            visitedNodesinOrder.push(curNode)\r\n            if( curNode.type ==='end') return visitedNodesinOrder\r\n\r\n            for (var i = 0; i< 4 ;i++){\r\n                if (isValid(curNode.row +dx[i],curNode.col+dy[i], grid)){\r\n                    let newNode = grid[curNode.row +dx[i]][curNode.col+dy[i]]\r\n\r\n                    stack.push(newNode)\r\n\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n    }return visitedNodesinOrder\r\n\r\n}}\r\nfunction isValid(row,col,grid) {\r\n    if(row < 0 || row >= grid.length|| col < 0|| col >= grid[0].length) return false\r\n    if(grid[row][col].isVisited ) return false\r\n    if(grid[row][col].type ==='wall') return false\r\n\r\n    return true;\r\n}","import React from 'react'\r\nimport './Node.css';\r\n\r\n\r\nexport default class Node extends React.Component {\r\n\r\n    render() {\r\n\r\n        const {\r\n            col,\r\n            type,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            row,\r\n        } = this.props;\r\n        var extraClassName ='' ;\r\n        if ( type === 'end'){\r\n            extraClassName = 'node-finish'\r\n        }else if (type === 'start'){\r\n            extraClassName= 'node-start'\r\n        }else if (type === 'empty') {\r\n            extraClassName ='node-empty'\r\n        }else if ( type === 'wall'){\r\n            extraClassName= 'node-wall'\r\n        }else if ( type === 'visited'){\r\n            extraClassName= 'node-visited'\r\n        }else if ( type === 'shortest'){\r\n            extraClassName= 'node-shortest'\r\n        }\r\n        return (\r\n            <div\r\n\r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}> </div>\r\n        );\r\n\r\n    }\r\n}","import React,{Component} from \"react\";\r\nimport Node from './Node/Node'\r\nimport './Pathfinding.css'\r\nimport {bfs} from './Algorithms/BFS'\r\nimport {dfs} from './Algorithms/DFS'\r\nconst START_NODE_ROW = 7;\r\nconst START_NODE_COL = 10;\r\nconst FINISH_NODE_ROW = 7;\r\nconst FINISH_NODE_COL = 35;\r\nexport default class Pathfinding extends Component{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            mouseIsPressed: false,\r\n            algorithm:'',\r\n            visualizeButton : 'Visualize',\r\n            visualizing : false,\r\n            speed: 5,\r\n            boardClear : true,\r\n        };\r\n        this.myRef = React.createRef();\r\n    }\r\n    componentDidMount() {\r\n        const grid = makeFirstGrid()\r\n        this.setState({grid})\r\n    }\r\n    handleMouseDown(row, col) {\r\n\r\n        if (this.state.visualizing) return\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({grid: newGrid, mouseIsPressed: true});\r\n\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n\r\n        if (!this.state.mouseIsPressed || this.state.visualizing) return;\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({grid: newGrid});\r\n    }\r\n\r\n    handleMouseUp() {\r\n        this.setState({mouseIsPressed: false});\r\n    }\r\n    visualizeBFS() {\r\n        const {grid} = this.state\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n        var shortestPathNodes = this.shortestPath(startNode,finishNode)\r\n        this.animateVisitedPath(visitedNodesInOrder,shortestPathNodes)\r\n\r\n    }\r\n    visualizeDFS() {\r\n        const {grid} = this.state\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n        var shortestPathNodes = this.shortestPath(startNode,finishNode)\r\n        this.animateVisitedPath(visitedNodesInOrder,shortestPathNodes)\r\n\r\n    }\r\n    visualizeShortestPath(shortestPathNodes) {\r\n        if(shortestPathNodes.length ===0) this.updateState()\r\n        for (let i = 0; i < shortestPathNodes.length; i++) {\r\n            setTimeout(() => {\r\n\r\n                const node = shortestPathNodes[i];\r\n                if (this.checkStartEnd(node.row,node.col)){\r\n\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-shortest';}\r\n            }, this.state.speed * i)\r\n            if(i===shortestPathNodes.length-1){\r\n                this.updateState()\r\n\r\n                this.setState(this.setState({visualizing: false}))\r\n            }\r\n        }\r\n    }\r\n    animateVisitedPath(visitedNodesInOrder, shortestPathNodes){\r\n\r\n         for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n\r\n             setTimeout(() => {\r\n                 const node = visitedNodesInOrder[i];\r\n                 if (this.checkStartEnd(node.row,node.col)\r\n                 ) {\r\n                     document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                         'node node-visited';\r\n\r\n                 }\r\n\r\n\r\n             }, this.state.speed * i);\r\n             if (i === visitedNodesInOrder.length - 1) {\r\n                 setTimeout(() => {\r\n                     this.visualizeShortestPath(shortestPathNodes);\r\n                 }, this.state.speed * i);\r\n                 return;\r\n             }\r\n\r\n         }\r\n    }\r\n    clearBoard(grid){\r\n        if (this.state.visualizing) return\r\n        this.clearObject(grid,'wall')\r\n        this.clearObject(grid,'visited')\r\n        this.clearObject(grid,'shortest')\r\n    }\r\n    clearObject(grid,block){\r\n        const newGrid = grid.slice()\r\n\r\n        for (var row = 0; row < this.state.grid.length;row ++){\r\n            for (var col = 0; col < this.state.grid[0].length;col ++){\r\n                const node = newGrid[row][col];\r\n                let type;\r\n                if(node.type === 'start'){\r\n                    type = 'start'\r\n                }else if(node.type === 'end') {\r\n                    type = 'end'\r\n                }else if(node.type === block){\r\n                    type = 'empty';\r\n                } else {\r\n                    type = node.type;\r\n                }\r\n                const newNode = {\r\n                    ...node,\r\n                    type :type,\r\n                    isVisited:false,\r\n                    previousNode:null\r\n\r\n                };\r\n\r\n                newGrid[row][col] = newNode;\r\n\r\n            }\r\n        }\r\n        this.setState({grid: newGrid});\r\n    }\r\n    shortestPath(startpoint ,endpoint) {\r\n        var  shortestPath = []\r\n        var temp = endpoint\r\n        if (endpoint.previousNode === null) return shortestPath\r\n        while(!(startpoint.row === temp.row && startpoint.col === temp.col) ){\r\n            shortestPath.push(temp)\r\n            temp = temp.previousNode;\r\n        }\r\n        shortestPath.push(startpoint)\r\n        return shortestPath\r\n    }\r\n    checkStartEnd(row,col){\r\n        if ((row === START_NODE_ROW && col === START_NODE_COL) ){\r\n            return false\r\n        }if(( row === FINISH_NODE_ROW && col === FINISH_NODE_COL)){\r\n            return false\r\n        }return true\r\n    }\r\n    updateState(){\r\n        let newGrid = this.state.grid\r\n        for (var row = 0; row < this.state.grid.length;row ++){\r\n            for (var col = 0; col < this.state.grid[0].length;col ++){\r\n                const node = newGrid[row][col];\r\n                if( document.getElementById(`node-${node.row}-${node.col}`).className=== 'node node-visited'){\r\n                    const newNode = {\r\n                        ...node,\r\n                        type :'visited',\r\n                    };\r\n                    newGrid[row][col] = newNode;\r\n                }else if( document.getElementById(`node-${node.row}-${node.col}`).className=== 'node node-shortest'){\r\n                    const newNode = {\r\n                        ...node,\r\n                        type :'shortest',\r\n                    };\r\n                    newGrid[row][col] = newNode;\r\n                }\r\n\r\n            }\r\n        }\r\n        newGrid[START_NODE_ROW][ START_NODE_COL].type= 'start'\r\n        newGrid[FINISH_NODE_ROW][ FINISH_NODE_COL].type= 'end'\r\n\r\n\r\n        this.setState({grid: newGrid});\r\n\r\n    }\r\n    onChangeAlgorithm(e) {\r\n        this.setState({algorithm: e.target.value}) ;\r\n        this.setState({visualizeButton: 'Visualize ' + e.target.value})\r\n\r\n    }\r\n    onChangeSpeed(e) {\r\n        this.setState({speed: parseInt(e.target.value)}) ;\r\n\r\n\r\n\r\n    }\r\n    visualize(){\r\n        if (this.state.visualizing) return\r\n        const algorithm = this.state.algorithm\r\n        if (algorithm === 'BFS'){\r\n            this.setState({visualizing: true});\r\n            this.checkBlocks()\r\n            this.setState({boardClear: false});\r\n            this.visualizeBFS()\r\n        }else if(algorithm === 'DFS'){\r\n            this.checkBlocks()\r\n            this.setState({visualizing: true})\r\n            this.visualizeDFS()\r\n        }else {\r\n            this.setState({visualizeButton: 'Pick an algorithm'})\r\n        }\r\n\r\n    }\r\n    checkBlocks(){\r\n        if (!this.state.boardClear){\r\n            this.clearObject(this.state.grid,'shortest')\r\n            this.clearObject(this.state.grid,'visited')\r\n            this.setState({boardClear: true});\r\n        }\r\n        this.setState({boardClear: false});\r\n    }\r\n    render() {\r\n      const {grid,mouseIsPressed} = this.state\r\n        return (\r\n            <>\r\n                <select className=\"form-control\"onChange={this.onChangeAlgorithm.bind(this)}>\r\n                    <option value=\"\">Pick an Algorithm</option>\r\n                    <option value=\"BFS\">Breadth First Search</option>\r\n                    <option value=\"DFS\">Depth First Search</option>\r\n                </select>\r\n\r\n\r\n                <button onClick={() => this.visualize()}>\r\n                    {this.state.visualizeButton}\r\n                </button>\r\n\r\n                <button onClick={() => this.clearBoard(grid)}>\r\n                    Clear Board\r\n                </button>\r\n                <select className=\"form-control\"onChange={this.onChangeSpeed.bind(this)} defaultValue={\"5\"} >\r\n                    <option value=\"2\">Really Fast</option>\r\n                    <option value=\"5\" >Fast</option>\r\n                    <option value=\"10\">Medium</option>\r\n                    <option value=\"20\">Slow</option>\r\n                </select>\r\n                <div className=\"grid\"  ref={this.myRef}>\r\n                    {grid.map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {row.map((node, nodeIdx) => {\r\n                                    const {row, col, type} = node;\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeIdx}\r\n                                            col={col}\r\n                                            type ={type}\r\n                                            mouseIsPressed={mouseIsPressed}\r\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                            onMouseEnter={(row, col) =>\r\n                                                this.handleMouseEnter(row, col)\r\n                                            }\r\n                                            onMouseUp={() => this.handleMouseUp()}\r\n                                            row={row}> </Node>\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </>\r\n        )\r\n    }\r\n\r\n}\r\nfunction makeFirstGrid(){\r\n    const grid =[]\r\n    for (let row=0;row<15; row++){\r\n        let rows =[];\r\n        for (let col=0;col< 45; col++){\r\n            rows.push(createCell(row,col))\r\n        }grid.push(rows)\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction createCell(row,col) {\r\n    let type;\r\n    if (row === START_NODE_ROW && col === START_NODE_COL){\r\n        type  ='start'\r\n    }else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\r\n        type = 'end'\r\n    }else {\r\n        type ='empty'\r\n    }\r\n    return {\r\n\r\n        col,\r\n        row,\r\n        type,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        previousNode: null,\r\n    }\r\n}\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    let type;\r\n    if(node.type === 'start'){\r\n        type  ='start'\r\n    }else if(node.type === 'end'){\r\n        type  ='end'\r\n    }\r\n    else if (node.type === 'wall'){\r\n        type  ='empty'\r\n    }else {\r\n        type = 'wall'\r\n    }\r\n    const newNode = {\r\n        ...node,\r\n        type :type\r\n\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};","import React from 'react';\nimport './App.css';\nimport Pathfinder from './Pathfinding/Pathfinding'\n\n\n\nfunction App() {\n  return (\n      < div className='App'>\n          <Pathfinder></Pathfinder>\n      </div>\n\n\n\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}